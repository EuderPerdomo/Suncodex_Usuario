{
  "version": 3,
  "sources": ["../../../../../../node_modules/three/examples/jsm/loaders/FontLoader.js"],
  "sourcesContent": ["import { FileLoader, Loader, ShapePath } from 'three';\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      const font = scope.parse(JSON.parse(text));\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\n\n//\n\nclass Font {\n  constructor(data) {\n    this.isFont = true;\n    this.type = 'Font';\n    this.data = data;\n  }\n  generateShapes(text, size = 100) {\n    const shapes = [];\n    const paths = createPaths(text, size, this.data);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      shapes.push(...paths[p].toShapes());\n    }\n    return shapes;\n  }\n}\nfunction createPaths(text, size, data) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n    offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      offsetX += ret.offsetX;\n      paths.push(ret.path);\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs['?'];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n      switch (action) {\n        case 'm':\n          // moveTo\n\n          x = outline[i++] * scale + offsetX;\n          y = outline[i++] * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case 'l':\n          // lineTo\n\n          x = outline[i++] * scale + offsetX;\n          y = outline[i++] * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case 'q':\n          // quadraticCurveTo\n\n          cpx = outline[i++] * scale + offsetX;\n          cpy = outline[i++] * scale + offsetY;\n          cpx1 = outline[i++] * scale + offsetX;\n          cpy1 = outline[i++] * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case 'b':\n          // bezierCurveTo\n\n          cpx = outline[i++] * scale + offsetX;\n          cpy = outline[i++] * scale + offsetY;\n          cpx1 = outline[i++] * scale + offsetX;\n          cpy1 = outline[i++] * scale + offsetY;\n          cpx2 = outline[i++] * scale + offsetX;\n          cpy2 = outline[i++] * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path: path\n  };\n}\nexport { FontLoader, Font };"],
  "mappings": "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",
  "names": []
}
